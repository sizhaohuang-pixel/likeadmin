# 套餐优先级使用策略

## 📋 功能概述

实现了"优先使用最早套餐"的策略，确保租户的多个套餐按照分配时间顺序使用，避免资源浪费和管理混乱。

## 🎯 核心原则

### 1. 时间优先原则
- **最早分配的套餐优先使用**
- 按 `assign_time` 升序排列套餐
- 先用完早期套餐，再使用后期套餐

### 2. 端口分配策略
```
租户有3个套餐：
套餐A: 100端口 (2024-01-01分配)
套餐B: 50端口  (2024-01-15分配) 
套餐C: 200端口 (2024-02-01分配)

分配顺序：A → B → C
```

### 3. 精确跟踪
- 小号表新增 `package_id` 字段
- 记录每个小号使用的具体套餐
- 支持精确的端口使用统计

## 🔧 技术实现

### 1. 数据库结构变更

#### 小号表新增字段
```sql
ALTER TABLE `la_alt_account` ADD COLUMN `package_id` int(11) DEFAULT NULL COMMENT '使用的套餐ID' AFTER `operator_id`;
```

#### 索引优化
```sql
-- 套餐ID索引
ALTER TABLE `la_alt_account` ADD KEY `idx_package_id` (`package_id`);

-- 租户套餐复合索引
ALTER TABLE `la_alt_account` ADD KEY `idx_tenant_package` (`tenant_id`, `package_id`);
```

### 2. 核心算法

#### 套餐优先级排序
```php
public static function getTenantPackagesByPriority(int $tenantId, bool $onlyValid = true): array
{
    $query = self::where('tenant_id', $tenantId);
    
    if ($onlyValid) {
        $query->where('status', 1)
              ->where('expire_time', '>', time());
    }
    
    return $query->order('assign_time', 'asc') // 最早的优先
                 ->select()
                 ->toArray();
}
```

#### 端口分配计算
```php
public static function calculatePortAllocationDetails(int $tenantId, int $usedPorts): array
{
    $packages = self::getTenantPackagesByPriority($tenantId, true);
    $allocationDetails = [];
    $remainingUsed = $usedPorts;
    
    foreach ($packages as $package) {
        $packageUsed = min($remainingUsed, $package['port_count']);
        $packageFree = $package['port_count'] - $packageUsed;
        
        $allocationDetails[] = [
            'package_id' => $package['id'],
            'port_total' => $package['port_count'],
            'port_used' => $packageUsed,
            'port_free' => $packageFree,
            'is_fully_used' => $packageUsed >= $package['port_count']
        ];
        
        $remainingUsed -= $packageUsed;
        if ($remainingUsed <= 0) break;
    }
    
    return $allocationDetails;
}
```

#### 小号分配逻辑
```php
private static function assignAccountsWithPackagePriority(array $altAccountIds, int $tenantId, int $operatorId): bool
{
    // 1. 获取套餐按优先级排序
    $packages = PackageAssignment::getTenantPackagesByPriority($tenantId, true);
    
    // 2. 计算各套餐的可用端口
    $allocationDetails = PackageAssignment::calculatePortAllocationDetails($tenantId, $currentUsedPorts);
    
    // 3. 按优先级分配小号到套餐
    $assignmentPlan = [];
    $remainingAccounts = count($altAccountIds);
    
    foreach ($allocationDetails as $detail) {
        if ($remainingAccounts <= 0) break;
        
        $availableInPackage = $detail['port_free'];
        if ($availableInPackage > 0) {
            $assignToThisPackage = min($remainingAccounts, $availableInPackage);
            $assignmentPlan[] = [
                'package_id' => $detail['package_id'],
                'count' => $assignToThisPackage
            ];
            $remainingAccounts -= $assignToThisPackage;
        }
    }
    
    // 4. 执行分配
    $accountIndex = 0;
    foreach ($assignmentPlan as $plan) {
        $accountsForThisPackage = array_slice($altAccountIds, $accountIndex, $plan['count']);
        
        AltAccount::where('id', 'in', $accountsForThisPackage)->update([
            'operator_id' => $operatorId,
            'package_id' => $plan['package_id'],
            'update_time' => time()
        ]);
        
        $accountIndex += $plan['count'];
    }
    
    return true;
}
```

## 📊 使用示例

### 场景1：多套餐分配
```
租户有2个套餐：
- 套餐A: 100端口 (2024-01-01分配)
- 套餐B: 50端口  (2024-01-15分配)

当前已分配80个小号：
- 套餐A: 80个小号 (已用80/100)
- 套餐B: 0个小号  (已用0/50)

新分配30个小号：
- 套餐A: 分配20个 (用满100/100)
- 套餐B: 分配10个 (已用10/50)
```

### 场景2：套餐过期处理
```
套餐A过期后：
- 套餐A的小号保持分配状态
- package_id 保持不变（历史记录）
- 新分配只使用套餐B的端口
```

## 🎯 业务价值

### 1. 资源优化
- **避免浪费**: 优先用完早期套餐，避免过期浪费
- **成本控制**: 合理利用已购买的端口资源
- **容量规划**: 清晰的套餐使用顺序

### 2. 管理清晰
- **使用透明**: 每个套餐的使用情况一目了然
- **历史追踪**: 完整的端口使用历史记录
- **精确统计**: 基于实际使用的精确统计

### 3. 运营效率
- **自动分配**: 系统自动按优先级分配
- **智能提醒**: 基于使用顺序的续费提醒
- **数据分析**: 支持更精确的使用分析

## 🔍 查询示例

### 查询套餐使用情况
```sql
-- 查询租户各套餐的端口使用情况
SELECT 
    pa.id as package_id,
    pa.port_count as total_ports,
    COUNT(aa.id) as used_ports,
    (pa.port_count - COUNT(aa.id)) as free_ports,
    pa.assign_time,
    pa.expire_time
FROM la_package_assignment pa
LEFT JOIN la_alt_account aa ON pa.id = aa.package_id AND aa.operator_id > 0
WHERE pa.tenant_id = ? AND pa.status = 1 AND pa.expire_time > UNIX_TIMESTAMP()
GROUP BY pa.id
ORDER BY pa.assign_time ASC;
```

### 查询小号分配详情
```sql
-- 查询小号使用的套餐信息
SELECT 
    aa.id,
    aa.phone,
    aa.operator_id,
    pa.id as package_id,
    pa.assign_time as package_assign_time,
    pa.expire_time as package_expire_time
FROM la_alt_account aa
LEFT JOIN la_package_assignment pa ON aa.package_id = pa.id
WHERE aa.tenant_id = ? AND aa.operator_id > 0;
```

## 💡 最佳实践

### 1. 套餐规划
- 合理规划套餐购买时间
- 避免同时购买过多套餐
- 考虑业务增长的时间节点

### 2. 监控提醒
- 监控早期套餐的使用率
- 提前规划续费策略
- 关注即将过期的套餐

### 3. 数据分析
- 分析套餐使用效率
- 优化套餐购买策略
- 基于历史数据预测需求

这个策略确保了租户的多套餐资源得到最优化的使用，提高了资源利用率和管理效率。
